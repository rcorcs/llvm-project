/home/rodrigo/regroll/evaluation
LoopRolling
RegionRoller at function: example
Reference Region: entry -> if.end
Link: if.end
Found Isomorphic:if.end => if.end9
Found Isomorphic:if.end9 => if.end16
Found Isomorphic:if.end16 => if.end23
Final Isomorphic Graph: 4, 3
ENTRY Blocks:
   entry
   if.end
   if.end9
   if.end16
Blocks:
   if.then
   if.then5
   if.then12
   if.then19
EXIT Blocks:
   if.end
   if.end9
   if.end16
   if.end23
-----
Let's do it
Creating AlignedBlock Node
Creating Node
  BB: entry
  BB: if.end
  BB: if.end9
  BB: if.end16
Has instruction: 0
Blocks Found: 0
ValidBlock: 1
Creating LABEL Node
  BB: entry
  BB: if.end
  BB: if.end9
  BB: if.end16
Creating AlignedBlock Node
Creating Node
  BB: if.then
  BB: if.then5
  BB: if.then12
  BB: if.then19
Has instruction: 0
Blocks Found: 0
ValidBlock: 1
Creating LABEL Node
  BB: if.then
  BB: if.then5
  BB: if.then12
  BB: if.then19
Creating AlignedBlock Node
Creating Node
  BB: if.end
  BB: if.end9
  BB: if.end16
  BB: if.end23
Has instruction: 0
Blocks Found: 0
ValidBlock: 1
Creating LABEL Node
  BB: if.end
  BB: if.end9
  BB: if.end16
  BB: if.end23
Aligning:
Entry Node

entry:
  %0 = load float, float* %B, align 4, !tbaa !2
  %cmp = fcmp ogt float %0, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.end


if.end:                                           ; preds = %if.then, %entry
  tail call void (...) @dummy() #2
  %arrayidx3 = getelementptr inbounds float, float* %B, i64 1
  %1 = load float, float* %arrayidx3, align 4, !tbaa !2
  %cmp4 = fcmp ogt float %1, 0.000000e+00
  br i1 %cmp4, label %if.then5, label %if.end9


if.end9:                                          ; preds = %if.then5, %if.end
  tail call void (...) @dummy() #2
  %arrayidx10 = getelementptr inbounds float, float* %B, i64 2
  %2 = load float, float* %arrayidx10, align 4, !tbaa !2
  %cmp11 = fcmp ogt float %2, 0.000000e+00
  br i1 %cmp11, label %if.then12, label %if.end16


if.end16:                                         ; preds = %if.then12, %if.end9
  tail call void (...) @dummy() #2
  %arrayidx17 = getelementptr inbounds float, float* %B, i64 3
  %3 = load float, float* %arrayidx17, align 4, !tbaa !2
  %cmp18 = fcmp ogt float %3, 0.000000e+00
  br i1 %cmp18, label %if.then19, label %if.end23

Analyzing
  br i1 %cmp, label %if.then, label %if.end
  br i1 %cmp4, label %if.then5, label %if.end9
  br i1 %cmp11, label %if.then12, label %if.end16
  br i1 %cmp18, label %if.then19, label %if.end23
Creating new root node
Creating Node
  br i1 %cmp, label %if.then, label %if.end
  br i1 %cmp4, label %if.then5, label %if.end9
  br i1 %cmp11, label %if.then12, label %if.end16
  br i1 %cmp18, label %if.then19, label %if.end23
Has instruction: 1
Blocks Found: 1
ValidBlock: 1
Valid blocks: testing match
match analysis
comparing two instructions for matching
match analysis
comparing two instructions for matching
match analysis
comparing two instructions for matching
Match: 1
4 x 4
Final Match: 1
Matching
  br i1 %cmp, label %if.then, label %if.end
  br i1 %cmp4, label %if.then5, label %if.end9
  br i1 %cmp11, label %if.then12, label %if.end16
  br i1 %cmp18, label %if.then19, label %if.end23
NodeTracker:Created: br
Creating Node
  %cmp = fcmp ogt float %0, 0.000000e+00
  %cmp4 = fcmp ogt float %1, 0.000000e+00
  %cmp11 = fcmp ogt float %2, 0.000000e+00
  %cmp18 = fcmp ogt float %3, 0.000000e+00
Has instruction: 1
Blocks Found: 1
ValidBlock: 1
Valid blocks: testing match
match analysis
comparing two instructions for matching
match analysis
comparing two instructions for matching
match analysis
comparing two instructions for matching
Match: 1
4 x 4
Final Match: 1
Matching
  %cmp = fcmp ogt float %0, 0.000000e+00
  %cmp4 = fcmp ogt float %1, 0.000000e+00
  %cmp11 = fcmp ogt float %2, 0.000000e+00
  %cmp18 = fcmp ogt float %3, 0.000000e+00
Creating Node
  %0 = load float, float* %B, align 4, !tbaa !2
  %1 = load float, float* %arrayidx3, align 4, !tbaa !2
  %2 = load float, float* %arrayidx10, align 4, !tbaa !2
  %3 = load float, float* %arrayidx17, align 4, !tbaa !2
Has instruction: 1
Blocks Found: 1
ValidBlock: 1
Valid blocks: testing match
match analysis
comparing two instructions for matching
match analysis
comparing two instructions for matching
match analysis
comparing two instructions for matching
Match: 1
4 x 4
Final Match: 1
Matching
  %0 = load float, float* %B, align 4, !tbaa !2
  %1 = load float, float* %arrayidx3, align 4, !tbaa !2
  %2 = load float, float* %arrayidx10, align 4, !tbaa !2
  %3 = load float, float* %arrayidx17, align 4, !tbaa !2
Creating Node
float* %B
  %arrayidx3 = getelementptr inbounds float, float* %B, i64 1
  %arrayidx10 = getelementptr inbounds float, float* %B, i64 2
  %arrayidx17 = getelementptr inbounds float, float* %B, i64 3
Has instruction: 1
Blocks Found: 1
ValidBlock: 1
Valid blocks: testing match
match analysis
Match: 0
4 x 4
Final Match: 0
Ptr: float* %B
AllGEPs: 0
GEP Seq
GEP Seq
float* %B
  %arrayidx3 = getelementptr inbounds float, float* %B, i64 1
  %arrayidx10 = getelementptr inbounds float, float* %B, i64 2
  %arrayidx17 = getelementptr inbounds float, float* %B, i64 3
Creating Node
i64 0
i64 1
i64 2
i64 3
Has instruction: 0
Blocks Found: 0
ValidBlock: 1
Valid blocks: testing match
match analysis
Match: 0
4 x 4
Final Match: 0
Int Seq
i64 0
i64 1
i64 2
i64 3
Creating Node
float 0.000000e+00
float 0.000000e+00
float 0.000000e+00
float 0.000000e+00
Has instruction: 0
Blocks Found: 0
ValidBlock: 1
All the Same
Node found!
  %cmp = fcmp ogt float %0, 0.000000e+00
  %cmp4 = fcmp ogt float %1, 0.000000e+00
  %cmp11 = fcmp ogt float %2, 0.000000e+00
  %cmp18 = fcmp ogt float %3, 0.000000e+00
NodeTracker:Found: fcmp
Node found!
  %0 = load float, float* %B, align 4, !tbaa !2
  %1 = load float, float* %arrayidx3, align 4, !tbaa !2
  %2 = load float, float* %arrayidx10, align 4, !tbaa !2
  %3 = load float, float* %arrayidx17, align 4, !tbaa !2
NodeTracker:Found: load
Analyzing
  %arrayidx3 = getelementptr inbounds float, float* %B, i64 1
  %arrayidx10 = getelementptr inbounds float, float* %B, i64 2
  %arrayidx17 = getelementptr inbounds float, float* %B, i64 3
Found GEP node
NodeTracker:Found:GEP: GEP seq.
Analyzing
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
Ended with incomplete group of instruction
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
Scheduled nodes:
GEP seq.
load
fcmp
br
GEPSEQ:CHECK: GEP seq. children op[0]=INTSEQ 
MATCH:CHECK: load children op[0]=GEPSEQ 
MATCH:CHECK: fcmp children op[0]=MATCH op[1]=IDENTICAL 
MATCH:CHECK: br children op[0]=MATCH op[1]=LABEL op[2]=LABEL 
Aligning:

if.then:                                          ; preds = %entry
  %mul = fmul float %0, %factor
  store float %mul, float* %A, align 4, !tbaa !2
  br label %if.end


if.then5:                                         ; preds = %if.end
  %mul7 = fmul float %1, %factor
  %arrayidx8 = getelementptr inbounds float, float* %A, i64 1
  store float %mul7, float* %arrayidx8, align 4, !tbaa !2
  br label %if.end9


if.then12:                                        ; preds = %if.end9
  %mul14 = fmul float %2, %factor
  %arrayidx15 = getelementptr inbounds float, float* %A, i64 2
  store float %mul14, float* %arrayidx15, align 4, !tbaa !2
  br label %if.end16


if.then19:                                        ; preds = %if.end16
  %mul21 = fmul float %3, %factor
  %arrayidx22 = getelementptr inbounds float, float* %A, i64 3
  store float %mul21, float* %arrayidx22, align 4, !tbaa !2
  br label %if.end23

Analyzing
  br label %if.end
  br label %if.end9
  br label %if.end16
  br label %if.end23
Creating new root node
Creating Node
  br label %if.end
  br label %if.end9
  br label %if.end16
  br label %if.end23
Has instruction: 1
Blocks Found: 1
ValidBlock: 1
Valid blocks: testing match
match analysis
comparing two instructions for matching
match analysis
comparing two instructions for matching
match analysis
comparing two instructions for matching
Match: 1
4 x 4
Final Match: 1
Matching
  br label %if.end
  br label %if.end9
  br label %if.end16
  br label %if.end23
NodeTracker:Created: br
Analyzing
  store float %mul, float* %A, align 4, !tbaa !2
  store float %mul7, float* %arrayidx8, align 4, !tbaa !2
  store float %mul14, float* %arrayidx15, align 4, !tbaa !2
  store float %mul21, float* %arrayidx22, align 4, !tbaa !2
Creating new root node
Creating Node
  store float %mul, float* %A, align 4, !tbaa !2
  store float %mul7, float* %arrayidx8, align 4, !tbaa !2
  store float %mul14, float* %arrayidx15, align 4, !tbaa !2
  store float %mul21, float* %arrayidx22, align 4, !tbaa !2
Has instruction: 1
Blocks Found: 1
ValidBlock: 1
Valid blocks: testing match
match analysis
comparing two instructions for matching
match analysis
comparing two instructions for matching
match analysis
comparing two instructions for matching
Match: 1
4 x 4
Final Match: 1
Matching
  store float %mul, float* %A, align 4, !tbaa !2
  store float %mul7, float* %arrayidx8, align 4, !tbaa !2
  store float %mul14, float* %arrayidx15, align 4, !tbaa !2
  store float %mul21, float* %arrayidx22, align 4, !tbaa !2
NodeTracker:Created: store
Creating Node
  %mul = fmul float %0, %factor
  %mul7 = fmul float %1, %factor
  %mul14 = fmul float %2, %factor
  %mul21 = fmul float %3, %factor
Has instruction: 1
Blocks Found: 1
ValidBlock: 1
Valid blocks: testing match
match analysis
comparing two instructions for matching
match analysis
comparing two instructions for matching
match analysis
comparing two instructions for matching
Match: 1
4 x 4
Final Match: 1
Matching
  %mul = fmul float %0, %factor
  %mul7 = fmul float %1, %factor
  %mul14 = fmul float %2, %factor
  %mul21 = fmul float %3, %factor
Creating Node
float %factor
float %factor
float %factor
float %factor
Has instruction: 0
Blocks Found: 0
ValidBlock: 1
All the Same
Creating Node
float* %A
  %arrayidx8 = getelementptr inbounds float, float* %A, i64 1
  %arrayidx15 = getelementptr inbounds float, float* %A, i64 2
  %arrayidx22 = getelementptr inbounds float, float* %A, i64 3
Has instruction: 1
Blocks Found: 1
ValidBlock: 1
Valid blocks: testing match
match analysis
Match: 0
4 x 4
Final Match: 0
Ptr: float* %A
AllGEPs: 0
GEP Seq
GEP Seq
float* %A
  %arrayidx8 = getelementptr inbounds float, float* %A, i64 1
  %arrayidx15 = getelementptr inbounds float, float* %A, i64 2
  %arrayidx22 = getelementptr inbounds float, float* %A, i64 3
Analyzing
  %mul = fmul float %0, %factor
  %arrayidx8 = getelementptr inbounds float, float* %A, i64 1
  %arrayidx15 = getelementptr inbounds float, float* %A, i64 2
  %arrayidx22 = getelementptr inbounds float, float* %A, i64 3
Found GEP node
NodeTracker:Found:GEP: GEP seq.
Node found!
  %mul = fmul float %0, %factor
  %mul7 = fmul float %1, %factor
  %mul14 = fmul float %2, %factor
  %mul21 = fmul float %3, %factor
NodeTracker:Found: fmul
Scheduled nodes:
fmul
GEP seq.
store
br
MATCH:CHECK: fmul children op[0]=MATCH op[1]=IDENTICAL 
GEPSEQ:CHECK: GEP seq. children op[0]=INTSEQ 
MATCH:CHECK: store children op[0]=MATCH op[1]=GEPSEQ 
MATCH:CHECK: br children op[0]=LABEL 
Aligning:
Exit Node

if.end:                                           ; preds = %if.then, %entry
  tail call void (...) @dummy() #2
  %arrayidx3 = getelementptr inbounds float, float* %B, i64 1
  %1 = load float, float* %arrayidx3, align 4, !tbaa !2
  %cmp4 = fcmp ogt float %1, 0.000000e+00
  br i1 %cmp4, label %if.then5, label %if.end9


if.end9:                                          ; preds = %if.then5, %if.end
  tail call void (...) @dummy() #2
  %arrayidx10 = getelementptr inbounds float, float* %B, i64 2
  %2 = load float, float* %arrayidx10, align 4, !tbaa !2
  %cmp11 = fcmp ogt float %2, 0.000000e+00
  br i1 %cmp11, label %if.then12, label %if.end16


if.end16:                                         ; preds = %if.then12, %if.end9
  tail call void (...) @dummy() #2
  %arrayidx17 = getelementptr inbounds float, float* %B, i64 3
  %3 = load float, float* %arrayidx17, align 4, !tbaa !2
  %cmp18 = fcmp ogt float %3, 0.000000e+00
  br i1 %cmp18, label %if.then19, label %if.end23


if.end23:                                         ; preds = %if.then19, %if.end16
  tail call void (...) @dummy() #2
  ret void

Processing Exit Blocks
Searching for instruction in last exit block
Creating Node
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
Has instruction: 1
Blocks Found: 2
ValidBlock: 1
Valid blocks: testing match
match analysis
comparing two instructions for matching
Call1
Call2
; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

Call3
match analysis
comparing two instructions for matching
Call1
Call2
; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

Call3
match analysis
comparing two instructions for matching
Call1
Call2
; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

Call3
Match: 1
4 x 4
Final Match: 1
Matching
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
NodeTracker:Created: call: dummy
Found good match
Done searching: 1
Exit block alignment starts with:
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
Analyzing
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
Creating new root node
Creating Node
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
Has instruction: 1
Blocks Found: 2
ValidBlock: 1
Valid blocks: testing match
match analysis
comparing two instructions for matching
Call1
Call2
; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

Call3
match analysis
comparing two instructions for matching
Call1
Call2
; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

Call3
match analysis
comparing two instructions for matching
Call1
Call2
; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

Call3
Match: 1
4 x 4
Final Match: 1
Matching
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
  tail call void (...) @dummy() #2
NodeTracker:Created: call: dummy
Creating Node
; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

; Function Attrs: optsize
declare dso_local void @dummy(...) local_unnamed_addr #1

Has instruction: 0
Blocks Found: 0
ValidBlock: 1
All the Same
Scheduled nodes:
call: dummy
MATCH:CHECK: call: dummy children op[0]=IDENTICAL 
Done
ALIGNMENT: 0/9(PROFITABLE)  ISOMORPHIC REGIONS: 4 regions, 3 blocks each!
Generating code for AB
Generating code in: rolled.reg.bb
generateNode: GEP seq.
Generating GEPSEQ
Closing GEPSEQ
Gen:   %5 = getelementptr float, float* %B, i64 0
generateNode: DONE
generateNode: load
Generating MATCH
Operands done!
generateNode 1
generateNode 2
generateNode 3
generateNode 4
generateNode 5
generateNode 6
generateNode: DONE
generateNode: fcmp
Generating MATCH
Operands done!
generateNode 1
generateNode 2
generateNode 3
generateNode 4
generateNode 5
generateNode 6
generateNode: DONE
generateNode: br
Generating MATCH
Operands done!
generateNode 1
generateNode 2
generateNode 3
generateNode 4
generateNode 5
generateNode 6
generateNode: DONE
Generating code for AB
Generating code in: rolled.reg.bb1
generateNode: fmul
Generating MATCH
Operands done!
generateNode 1
generateNode 2
generateNode 3
generateNode 4
generateNode 5
generateNode 6
generateNode: DONE
generateNode: GEP seq.
Generating GEPSEQ
Closing GEPSEQ
Gen:   %9 = getelementptr float, float* %A, i64 0
generateNode: DONE
generateNode: store
Generating MATCH
Operands done!
generateNode 1
generateNode 2
generateNode 3
generateNode 4
generateNode 5
generateNode 6
generateNode: DONE
generateNode: br
Generating MATCH
Operands done!
generateNode 1
generateNode 2
generateNode 3
generateNode 4
generateNode 5
generateNode 6
generateNode: DONE
Generating code for AB
Generating code in: rolled.reg.bb2
generateNode: call: dummy
Generating MATCH
Operands done!
generateNode 1
generateNode 2
generateNode 3
generateNode 4
generateNode 5
generateNode 6
generateNode: DONE
setting operands GEPSEQ
Here?? need to generate node value
Generating INTSEQ
Gen:   %5 = zext i8 %4 to i64
Setting operands MATCH
Found Label operand
Setting operands MATCH
Found Label operand
Here?? need to generate node value
Generating IDENTICAL
Setting operands MATCH
Found Label operand
Getting Label operand
  BB: if.end
  BB: if.end9
  BB: if.end16
  BB: if.end23
Found Label operand
Getting Label operand
  BB: if.then
  BB: if.then5
  BB: if.then12
  BB: if.then19
Found Label operand
Setting operands MATCH
Found Label operand
Here?? need to generate node value
Generating IDENTICAL
setting operands GEPSEQ
Found Label operand
Setting operands MATCH
Found Label operand
Found Label operand
Setting operands MATCH
Getting Label operand
  BB: if.end
  BB: if.end9
  BB: if.end16
  BB: if.end23
Found Label operand
Setting operands MATCH
Here?? need to generate node value
Generating IDENTICAL
; Function Attrs: nounwind optsize uwtable
define dso_local void @example(float* nocapture %A, float* nocapture readonly %B, float %factor) local_unnamed_addr #0 {
entry:
  %0 = load float, float* %B, align 4, !tbaa !2
  %cmp = fcmp ogt float %0, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mul = fmul float %0, %factor
  store float %mul, float* %A, align 4, !tbaa !2
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  tail call void (...) @dummy() #2
  %arrayidx3 = getelementptr inbounds float, float* %B, i64 1
  %1 = load float, float* %arrayidx3, align 4, !tbaa !2
  %cmp4 = fcmp ogt float %1, 0.000000e+00
  br i1 %cmp4, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end
  %mul7 = fmul float %1, %factor
  %arrayidx8 = getelementptr inbounds float, float* %A, i64 1
  store float %mul7, float* %arrayidx8, align 4, !tbaa !2
  br label %if.end9

if.end9:                                          ; preds = %if.then5, %if.end
  tail call void (...) @dummy() #2
  %arrayidx10 = getelementptr inbounds float, float* %B, i64 2
  %2 = load float, float* %arrayidx10, align 4, !tbaa !2
  %cmp11 = fcmp ogt float %2, 0.000000e+00
  br i1 %cmp11, label %if.then12, label %if.end16

if.then12:                                        ; preds = %if.end9
  %mul14 = fmul float %2, %factor
  %arrayidx15 = getelementptr inbounds float, float* %A, i64 2
  store float %mul14, float* %arrayidx15, align 4, !tbaa !2
  br label %if.end16

if.end16:                                         ; preds = %if.then12, %if.end9
  tail call void (...) @dummy() #2
  %arrayidx17 = getelementptr inbounds float, float* %B, i64 3
  %3 = load float, float* %arrayidx17, align 4, !tbaa !2
  %cmp18 = fcmp ogt float %3, 0.000000e+00
  br i1 %cmp18, label %if.then19, label %if.end23

if.then19:                                        ; preds = %if.end16
  %mul21 = fmul float %3, %factor
  %arrayidx22 = getelementptr inbounds float, float* %A, i64 3
  store float %mul21, float* %arrayidx22, align 4, !tbaa !2
  br label %if.end23

if.end23:                                         ; preds = %if.then19, %if.end16
  tail call void (...) @dummy() #2
  ret void

rolled.reg.pre:                                   ; No predecessors!

rolled.reg.loop:                                  ; No predecessors!
  %4 = phi i8 

rolled.reg.bb:                                    ; No predecessors!
  %5 = zext i8 %4 to i64
  %6 = getelementptr float, float* %B, i64 %5
  %7 = load float, float* %6, align 4
  %8 = fcmp ogt float %7, 0.000000e+00
  br i1 %8, label %rolled.reg.bb1, label %rolled.reg.latch

rolled.reg.bb1:                                   ; preds = %rolled.reg.bb
  %9 = fmul float %7, %factor
  %10 = getelementptr float, float* %A, i64 %5
  store float %9, float* %10, align 4
  br label %rolled.reg.latch

rolled.reg.bb2:                                   ; No predecessors!
  tail call void (...) @dummy() #2

rolled.reg.latch:                                 ; preds = %rolled.reg.bb1, %rolled.reg.bb
}

Computing size of original code
Computing size of rolled code
Size of BB: rolled.reg.pre

rolled.reg.pre:                                   ; No predecessors!

size: 0
Size of BB: rolled.reg.loop

rolled.reg.loop:                                  ; No predecessors!
  %4 = phi i8 

size: 0
Size of BB: rolled.reg.bb

rolled.reg.bb:                                    ; No predecessors!
  %5 = zext i8 %4 to i64
  %6 = getelementptr float, float* %B, i64 %5
  %7 = load float, float* %6, align 4
  %8 = fcmp ogt float %7, 0.000000e+00
  br i1 %8, label %rolled.reg.bb1, label %rolled.reg.latch

size: 6
Size of BB: rolled.reg.bb1

rolled.reg.bb1:                                   ; preds = %rolled.reg.bb
  %9 = fmul float %7, %factor
  %10 = getelementptr float, float* %A, i64 %5
  store float %9, float* %10, align 4
  br label %rolled.reg.latch

size: 5
Size of BB: rolled.reg.bb2

rolled.reg.bb2:                                   ; No predecessors!
  tail call void (...) @dummy() #2

size: 1
Size of BB: rolled.reg.latch

rolled.reg.latch:                                 ; preds = %rolled.reg.bb1, %rolled.reg.bb
  %11 = add i8 %4, 1
  %12 = icmp ne i8 %11, 4

size: 2
Cost Original: 42, Cost Rolled: 14, Profitable
; Function Attrs: nounwind optsize uwtable
define dso_local void @example(float* nocapture %A, float* nocapture readonly %B, float %factor) local_unnamed_addr #0 {
entry:
  %0 = load float, float* %B, align 4, !tbaa !2
  %cmp = fcmp ogt float %0, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mul = fmul float %0, %factor
  store float %mul, float* %A, align 4, !tbaa !2
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  tail call void (...) @dummy() #2
  %arrayidx3 = getelementptr inbounds float, float* %B, i64 1
  %1 = load float, float* %arrayidx3, align 4, !tbaa !2
  %cmp4 = fcmp ogt float %1, 0.000000e+00
  br i1 %cmp4, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end
  %mul7 = fmul float %1, %factor
  %arrayidx8 = getelementptr inbounds float, float* %A, i64 1
  store float %mul7, float* %arrayidx8, align 4, !tbaa !2
  br label %if.end9

if.end9:                                          ; preds = %if.then5, %if.end
  tail call void (...) @dummy() #2
  %arrayidx10 = getelementptr inbounds float, float* %B, i64 2
  %2 = load float, float* %arrayidx10, align 4, !tbaa !2
  %cmp11 = fcmp ogt float %2, 0.000000e+00
  br i1 %cmp11, label %if.then12, label %if.end16

if.then12:                                        ; preds = %if.end9
  %mul14 = fmul float %2, %factor
  %arrayidx15 = getelementptr inbounds float, float* %A, i64 2
  store float %mul14, float* %arrayidx15, align 4, !tbaa !2
  br label %if.end16

if.end16:                                         ; preds = %if.then12, %if.end9
  tail call void (...) @dummy() #2
  %arrayidx17 = getelementptr inbounds float, float* %B, i64 3
  %3 = load float, float* %arrayidx17, align 4, !tbaa !2
  %cmp18 = fcmp ogt float %3, 0.000000e+00
  br i1 %cmp18, label %if.then19, label %if.end23

if.then19:                                        ; preds = %if.end16
  %mul21 = fmul float %3, %factor
  %arrayidx22 = getelementptr inbounds float, float* %A, i64 3
  store float %mul21, float* %arrayidx22, align 4, !tbaa !2
  br label %if.end23

if.end23:                                         ; preds = %if.then19, %if.end16
  tail call void (...) @dummy() #2
  ret void

rolled.reg.pre:                                   ; No predecessors!
  br label %rolled.reg.loop

rolled.reg.loop:                                  ; preds = %rolled.reg.pre, %rolled.reg.latch
  %4 = phi i8 [ 0, %rolled.reg.pre ], [ %11, %rolled.reg.latch ]
  br label %rolled.reg.bb

rolled.reg.bb:                                    ; preds = %rolled.reg.loop
  %5 = zext i8 %4 to i64
  %6 = getelementptr float, float* %B, i64 %5
  %7 = load float, float* %6, align 4
  %8 = fcmp ogt float %7, 0.000000e+00
  br i1 %8, label %rolled.reg.bb1, label %rolled.reg.latch

rolled.reg.bb1:                                   ; preds = %rolled.reg.bb
  %9 = fmul float %7, %factor
  %10 = getelementptr float, float* %A, i64 %5
  store float %9, float* %10, align 4
  br label %rolled.reg.latch

rolled.reg.bb2:                                   ; preds = %rolled.reg.latch
  tail call void (...) @dummy() #2

rolled.reg.latch:                                 ; preds = %rolled.reg.bb1, %rolled.reg.bb
  %11 = add i8 %4, 1
  %12 = icmp ne i8 %11, 4
  br i1 %12, label %rolled.reg.loop, label %rolled.reg.bb2
}

Erasing old instructions
; Function Attrs: nounwind optsize uwtable
define dso_local void @example(float* nocapture %A, float* nocapture readonly %B, float %factor) local_unnamed_addr #0 {
entry:
  br label %rolled.reg.pre

if.end23:                                         ; preds = %rolled.reg.bb2
  ret void

rolled.reg.pre:                                   ; preds = %entry
  br label %rolled.reg.loop

rolled.reg.loop:                                  ; preds = %rolled.reg.pre, %rolled.reg.latch
  %0 = phi i8 [ 0, %rolled.reg.pre ], [ %7, %rolled.reg.latch ]
  br label %rolled.reg.bb

rolled.reg.bb:                                    ; preds = %rolled.reg.loop
  %1 = zext i8 %0 to i64
  %2 = getelementptr float, float* %B, i64 %1
  %3 = load float, float* %2, align 4
  %4 = fcmp ogt float %3, 0.000000e+00
  br i1 %4, label %rolled.reg.bb1, label %rolled.reg.latch

rolled.reg.bb1:                                   ; preds = %rolled.reg.bb
  %5 = fmul float %3, %factor
  %6 = getelementptr float, float* %A, i64 %1
  store float %5, float* %6, align 4
  br label %rolled.reg.latch

rolled.reg.bb2:                                   ; preds = %rolled.reg.latch
  tail call void (...) @dummy() #2
  br label %if.end23

rolled.reg.latch:                                 ; preds = %rolled.reg.bb1, %rolled.reg.bb
  %7 = add i8 %0, 1
  %8 = icmp ne i8 %7, 4
  br i1 %8, label %rolled.reg.loop, label %rolled.reg.bb2
}

Optimizing: example
BlockSize: 1
BlockSize: 1
getPossibleMinMaxReduction
BlockSize: 1
BlockSize: 2
collecting possible seeds from PHI Nodes
  %0 = phi i8 [ 0, %rolled.reg.pre ], [ %7, %rolled.reg.latch ]
i8 0
getPossibleMinMaxReduction
  %7 = add i8 %0, 1
getPossibleMinMaxReduction
BlockSize: 5
getPossibleMinMaxReduction
BlockSize: 4
Attempting Group:
BlockSize: 2
BlockSize: 3
getPossibleMinMaxReduction
Done Loop Roller: 0/0
Nothing found in: example
   text	   data	    bss	    dec	    hex	filename
    221	      0	      0	    221	     dd	region-3.c.o
   text	   data	    bss	    dec	    hex	filename
     88	      0	      0	     88	     58	region-3.c.opt.o
